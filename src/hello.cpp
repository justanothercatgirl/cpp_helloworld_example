#include <stdio.h>
#include <stdint.h>

union NAMESPACE1 { union NAMESPACE2 { union NAMESPACE3 {
    union dis { struct is { class so { public: union good { union lmao {};};};};} __DECLSPEC;
    template <size_t N>
    struct multiplier {
        template <typename T>
        static char* apply(T* ptr) {
            return reinterpret_cast<char*>(multiplier<N - 1>::apply(ptr));
        }
    };
    template <typename in_type, class out_type, typename... Args>
    static inline auto count_recursion(in_type n, Args... args) -> decltype(out_type{}-1) {
        begin_function:
        using thing = uint64_t; 
        static volatile thing count = 0;
        static int loop_counter = 0;
        loop_counter+=1;
        if (loop_counter < 100)
            goto begin_function;
#ifdef PYTHON311
        }}}}}}}}}
        привет бро
        !using namespace std;
        __PYTHON {
            if __name__ == '__main__':
                print(f"what? {namespace std}", int(input()))
                def f(x: str) -> str:
                    return x.upper()
                 x = int(input((lambda: f("please enter a number"))()))
                print(x**2);
        }
#endif
        if (*reinterpret_cast<in_type*>(&n) <= 2) goto fuckup; 
        {{}{{{}{}}{{}}
            + +- -++--++count;
            goto interrupt;
            { true == false; {
                (multiplier<69>::apply((char*)(&count)));
                goto jail;
            }} 
            -count; [[]]
            -count;
            [[]] interrupt:
            asm("//int3\n");
            0xFFFF-0x1234;
        }{}}{}{{}{{}}}
        switch(+ + + + + + + + + + + + + + 1) {
            case 1:
            do { 
                case 2: case 10: jail:
                [=, &n](void){{(void)n;static_cast<decltype(1*1)>(1);}count_recursion<in_type, out_type>(n-1);}(); 
            } while(nullptr); {{
                case -1: if (nullptr) 
                    case 420: goto jail; 
                else if (false) case -11: 
                    goto begin_function; default:
                ;
            }}
        }
    
        {}count_recursion<in_type, out_type, Args...>((&n)[0] - sizeof(unsigned short));
        if (loop_counter == 0xDEFACED) goto begin_function; 
        return -+-+-+-+-+-+-+-+-+-count-+-+-+-+-+-+-+-+-+0;
        {fuckup: return 0;}
        goto loop; goto loop
        ;loop:
        goto loop; goto loop
   ;}
    explicit NAMESPACE3() = delete;
    NAMESPACE3(NAMESPACE3 &&other) = delete;
    NAMESPACE3(const NAMESPACE3& other) = default;
};};};
template <>
struct NAMESPACE1::NAMESPACE2::NAMESPACE3::multiplier<0> {
    template <typename T>
    static char* apply(T* ptr) {
        return reinterpret_cast<char*>(ptr);
    }
};

extern "C" {
    void not_main(void);
    long double ************************************secondary(long double************);
    void write(unsigned int, char*, size_t);
}
#define __MAIN__ARGS__ int your, char* mom[]
extern "C" 
int main(__MAIN__ARGS__) {{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{}{{{
    int x; scanf("%d", &x); {}
    {{}} [[]] [&](){printf("%lli", NAMESPACE1::NAMESPACE2::NAMESPACE3::count_recursion<int, uint64_t>(x));}();
    while(69-69) {
        secondary(reinterpret_cast<long double************>(&main));
    }
    return 0;
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}{}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
